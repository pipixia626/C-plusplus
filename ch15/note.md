# 面向对象程序设计

## 概述

面向对象程序设计基于三个基本概念：数据抽象，继承和动态绑定

数据抽象：数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。
数据抽象是一种依赖于接口和实现分离的编程（设计）技术
继承：定义相似的类型并对其相似关系建模（层次）
动态绑定：在一定程度上忽略相似类型的区别,而以统一的方式使用它们的对象

## 基类和派生类
### 基类
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此
将两种成员函数分开来：
一种是基类希望派生类覆盖的函数：当使用指针或者引用调用虚函数时，该调用将被动态绑定根据引用或指针所绑定的对象类型不同执行对应的版本

另一种是基类希望派生类直接继承而不需要改变的函数
如果基类把 一个函数
声明成虚函数，则该函数在派生类中隐式地也是虚函数

虚函数在解析过程发生在运行时，静态：编译时
virtual 和override关键字
### 派生类
列表形式：
首先是一个冒号，后面紧跟以逗号分隔的基类列
表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected 或者 private

在派生类对象中含有与基类对应的组成部分，这是继承的关键所在
派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员，因此派生类也必须使用基类的构造函数来初始化它的基类部分（每个类控制它自己的成员初始化过程）

首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

#### 防止继承的发生：类名后面加final

将基类的指针绑定到派生类对象上

表达式的静态类型在编 译
时总是已知的，它是变量声明时的类型或表达式生成的类型：动态类型则是变量或表达 式
表示的内存中的对象的类型。动态类型直到运行时才可知

因为一个基类的对象可能是派生类对象的一部分.也可能不是，所以不存在从基类向
派生类的自动类型转换

派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换

## 虚函数
基类中的虚函数在派生类中隐含地也是一个虚函数当派生类覆盖了某个虚函
数时，该函数在基类中的形参必须与派生类中的形参严格匹配

如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致

对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数
的某个特定版本。使用作用域运算符可以实现这一目的
## 抽象基类

纯虚函数：
纯虚函数，在虚函数后加“=0”，如 virtual void func()=0
纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”

含有纯虚函数的类为抽象基类

## 访问控制和继承
每个类分别控制自己的成员初始化过程，还分别控制着成员对于派生类是否可访问

某个类对其继承而来的成员的访问权限控制收到两个因素影响：
1:基类中该成员的访问说明符
2：派生类的派生列表的访问说明符

基类成员的访问权限只与基类中的访问说明符有关
派生类说明符是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限

在类的内部使用Using 声明语句，可以将该类的直接或间接基类中的任何可访问成员标记出来
~~~
class SubClass:private BaseClass {
public:
    using BaseClass::BaseThing;
};
~~~

## 继承中的类作用域
派生类的作用域嵌套在其基类的作用域之内，当一个名字在派生类的作用域内无法正确解析时，编译器将继续在外层的基类作用域中寻找该名字的定义

## 构造函数与拷贝控制

## 容器与继承
