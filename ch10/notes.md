# 泛型算法


## 初识泛型算法

### 只读算法
算法中的两个序列可以来自于不同类型的容器，但最好保证相同元素类型，这样'=='就有效

find:寻找

accmulate:求和（第三个参数设初值）

equal:两个序列是否保存相同的值（第三个元素设置为第二个序列的第几个元素开始）

### 写算法
主要容器为空情况
fill 
insert

### 拷贝算法
计算新的元素的值，但不会把它们放置在输入序列的末尾，而是创建一个新的序列保存结果

copy
replace

### 重排容器元素算法
sort
sort+unique->去除相同元素

## 定制操作
sort: stable_sort


### lambda

#### 概念

一个lambda表达式表示一个可调用的代码单元
lambda表达式==未命名的内联函数

可调用对象：
函数和函数指针
重载了函数调用运算符的类


形式：[capature list](parameter list)->return type (function body)<br>

capature list:一个lambda所在函数中定义的局部变量的列表（通常为空）<br>
必须使用尾置返回来指定返回类型
可以忽略参数列表和返回类型，但必须永远包含列表和函数体

#### 示例
auto f = []{return 42;};

调用find_if

auto wc=find_if(words.begin(),words.end(),[sz](const string &a){return a.size()>=sz});

当定义一个lambda时，编译器生成一个与Lambda对应的新的（未命名）类类型，
这样理解：当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此
编译器生成的类类型未命名的对象，默认情况下，从lambda生成的类都包含一个对应lambda所捕获的变量和数据成员

对于那种只在一两个地方使用的简单操作，lambda表达式是最有用，多次使用的话还是用函数声明比较好


## 再探迭代器

### 插入迭代器
只有在容器支持push_front的情况下，我们才可以使用front_inserter :
类似的，只有在容器支持 push_back 的情况下，才能使用
back_inserter
front_inserter
inserter
### 流迭代器
### 反向迭代器除了forward_list之外的标准库都有

### 移动迭代器

## 泛型算法结构
反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要
的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭
代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素
[左闭右合区间]

迭代器类别
输入迭代器 只读，不写；单遍扫描，只能递增<br>
输出迭代器 只写，不读：单遍扫描，只能递增<br>
前向迭代器 可读写；多遍扫描，只能递增<br>
双向迭代器 可读写•，多遍扫描，可递增递减<br>
随机访问迭代器 可读写，多遍扫描，支持全部迭代器运算<br>

## 特定容器算法
根据不同容器的存储原理，有着不同的算法
