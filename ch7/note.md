# 类

## 抽象数据类型
定义在类内部的函数是隐式的inline函数
把解决一类问题的数据对象抽象成一类用来解决刻画问题
### this指针
相当于const 指针，指向当前对象，通过它可以访问当前对象的所有成员
实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给this，是隐式的，不出现在
代码中，而是在编译阶段由编译器添加到参数列表中。

## 访问控制和封装
public:声明的成员可以在整个程序内被访问
private：声明的成员可以被类的成员函数访问
## struct和class的唯一区别
struct 默认访问public
class 默认访问private

构造函数=default 可以设定默认构造函数

## 类的其他特性
### 友元
允许其他类或者函数访问它的非共有成员（friend 声明）

const 在函数名前面修饰的是函数返回值，在函数名后面表示的是常成员函数，该函数不能修改对象内的任何成员

但 mutable 修饰的数据成员永远不会是const的
### 封装有两个重要的优点
1：确保用户代码不会无意间破坏封装对象的状态
2：被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码


## 类的作用域

## 构造函数再探
按顺序初始化
const ,引用的初始化最好写在构造函数中

### 委托构造函数
使用它所属类的其他构造函数执行它自己的初始化过程，或者是说它把它自己的一些（全部）职责委托给了其他构造函数

### 隐式的类类型转换
能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型
隐式转换的规则<br>
具有一个实参的构造函数初始化对象时参数的隐式转换是通过临时构建一个对象，然后将对象用于对应的参数正确的类型
然后在构造函数完成之后销毁<br>
使用explict声明在函数之前 就可以
## 类的静态成员
静态成员数据是类的一部分，为类的所有实例共享（静态区）;
非静态静态成员，类的每个实例都有一份拷贝
### 访问
静态数据成员是类的一部分，在产生任何实例之前已经存在
静态函数成员与非静态数据成员都为类所有，对象中并不存在函数的拷贝（每个对象所占用的存储空间
只是该对象的数据成员所占用的存储空间，但是在逻辑上函数和数据一起被封装进对象的）

### 静态成员函数和非静态成员函数的根本区别在与有无this指针。
非静态函数由对象名.或者对象指针->调用，调用时编译器会向函数传递this指针；
静态成员函数则有类名：：或者对象名.调用，没有this指针
不识别对象个体，经常用来操作类的静态数据成员，访问类的非静态成员要通过对象实现
静态成员函数不能访问非静态成员函数（内存没分配）
静态数据成员的初始化在类体外进行

