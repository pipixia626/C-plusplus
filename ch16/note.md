# 模板和泛型编程

## preview
OOP能处理类型在程序运行之前都未知的情况

泛型编程：在编译时就能获知类型

容器、迭代器、算法

容器：一种可以持有其他对象或指向其他对象的指针，同时包含了一系列处理其他对象的方法

模板是泛型的基础
## 定义模板

### 类型模板参数

每个不同的参数，编译器会实例化对应类型的版本
### 非类型模板参数

一个非类型参数表示一个值而非一个类型
通过一个特定的类型名而非关键字 class 或 typename来指定非类型参数。


#### constexpr
c++11新增的关键字，语义是常量表达式，也就是在编译期间可求值的表达式

修饰构造函数：
constexpr还能用于修饰类的构造函数，即保证如果提供给该构造函数的参数都是constexpr，
那么产生的对象中的所有成员都会是constexpr，该对象也就是constexpr对象了，
可用于各种只能使用constexpr的场合。注意，constexpr构造函数必须有一个空的函数体，
即所有成员变量的初始化都放到初始化列表中

#### 优点
1：是一种很强的约束，更好地保证程序的正确语义不被破坏

2：编译器可以在编译期间对constexpr的代码进行非常大的优化，比如将constexpr表达式都直接替换成最终结果

3：相比于宏，没有额外的开销，但更安全可靠

当编译器遇到一个模板定义时，并不生成代码，只有实例化出模板一个特定版本时，编译器才会生成代码

函数模板和类模板成员函数的定义通常放在头文件中：

模板编译错误期间的报告：

1：编译模板本身：语法错误（变量名拼错）

2：编译器遇到模板使用时：检查参数数目，参数类型是否匹配

3：模板实例化：只有这个阶段才能发现类型相关的错误




## 模板实参推断

## 重载与模板

## 可变参数模板

## 模板特例化



















