# 变量和基本类型

## 基本内置类型
### 算数类型
#### 整型(包含字符和布尔类型）

bool 布尔类型 未定义
char 字符 8 位 signed char unsigned char
wchar t 宽字符 16 位
char16 t Unicode 字符 16 位
char32 t Unicode 字符 32 位
short 短整型 16 位
int 整型 16 位
long 长整型 32 位
long long 长整型 64 位
float 单精度浮点数 6 位有效数字
double 双精度浮点数 10 位有效数字
long double 扩展精度浮点数 10 位有效数字

#### 浮点型
单精度，双精度，扩展精度

### 空类型

### 类型转换
超出精度取模操作，后续还会再讨论

## 变量
每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、
该空间能存储的值的范围，以及变量能参与的运算，变量和对象一般可以交换使用

### 何为对象？
一块能存储数据并具有某种类型的内存空间

### 定义
类型说明符 变量名...
### 定义和声明关系
声明（declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含那给名字的声明
定义（definition)负责创建于名字关联的实体
变量只能被定义一次，但可以有多处声明

如果想声明一个变量而非定义它，就在变量名前添加关键字 extern,而且不要显式
地初始化变量：
extern int i; //声明 i 而非定义 i
int j; //声明并定义 j

任何包含了显式初始化的声明即成为定义。我们能给由 extern 关键字标记的变量赋
一个初始值，但是这么做也就抵消了 extern 的作用。extern 语句如果包含初始值就不
再是声明，而变成定义了：
extern double pi = 3.1416; // 定义
### 静态类
C++是一种静态类型（statically typed)语言，其含义是在编译阶段检查类型。其
中， 检查类型_的过程称为类型检查（type checking)
### 作用域
不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、等。
然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。

## 复合类型
是指基于其他类型定义的类型
### 引用
目前先为左值引用，后续c++11新增了右值引用
引用（reference）为对象起了另外一个名字，引用类型引用(refers to)另外一种类型
通过将声明符写出&d的形式来定义引用类型，其中d是声明的变量名

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和
它的初始值绑定（bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将
和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用
必须初始化
引用即别名，引用并非对象，相反的，它是为一个已经存在的对象所起的另外一个名字，一个引用之后，所有进行的
所有操作都是在与之绑定的对象上进行的
### 指针
指针（pointer)是“指向（point to)”另外一种类型的复合类型。与引用类似，指针 也
实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一指针本身 就
是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不 同
的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的 指
针如果没有被初始化，也将拥有一个不确定的值。

凡是定义了指针且不知道应该指向何处的就初始化为nullptr
#### 指向指针的指针
code:
## const限定符
因为 const 对象一旦创建后其值就不能再改变，所以 const 对象必须初始化
如果利用一个对象去初始化另外 一
个对象，则它们是不是 const 都无关紧要

当以编译时初始化的方式定义一个 const 对象时，就如对 bufSize 的定义一样： const 
int bufSize = 512; // 输入缓冲区大小
编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到
代码中所有用到 bufSize 的地方，然后用 512 替换。

默认情况下，const 对象被设定为仅在文件内有效。当 多
个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量
让多个文件共享这个const 变量解决办法： 
只在一个文件定义，在其他多个文件中声明并使用
extern const int bufsize
### const 引用
可以把引用绑定到 const 对象上，就像绑定到其他对象上一样，我们称之为对常量
的引用（reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑
定的对象：
## 定义数据结构
