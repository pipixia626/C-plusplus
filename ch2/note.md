# 变量和基本类型

## 基本内置类型
### 算数类型
#### 整型(包含字符和布尔类型）

bool 布尔类型 未定义 <br>
char 字符 8 位 signed char unsigned char <br>
wchar t 宽字符 16 位 <br>
char16 t Unicode 字符 16 位 <br>
char32 t Unicode 字符 32 位 <br>
short 短整型 16 位 <br>
int 整型 16 位 <br>
long 长整型 32 位  <br>
long long 长整型 64 位  <br>
float 单精度浮点数 6 位有效数字<br>
double 双精度浮点数 10 位有效数字 <br>
long double 扩展精度浮点数 10 位有效数字  <br>

#### 浮点型
单精度，双精度，扩展精度

### 空类型

### 类型转换
超出精度取模操作，后续还会再讨论

## 变量
每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、
该空间能存储的值的范围，以及变量能参与的运算，变量和对象一般可以交换使用

### 何为对象？
一块能存储数据并具有某种类型的内存空间

### 定义
类型说明符 变量名...
### 定义和声明关系
声明（declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含那给名字的声明
定义（definition)负责创建于名字关联的实体
变量只能被定义一次，但可以有多处声明

如果想声明一个变量而非定义它，就在变量名前添加关键字 extern,而且不要显式
地初始化变量：<br>
extern int i; //声明 i 而非定义 i <br>
int j; //声明并定义 j  <br>

任何包含了显式初始化的声明即成为定义。我们能给由 extern 关键字标记的变量赋
一个初始值，但是这么做也就抵消了 extern 的作用。extern 语句如果包含初始值就不
再是声明，而变成定义了：
extern double pi = 3.1416; // 定义
### 静态类
C++是一种静态类型（statically typed)语言，其含义是在编译阶段检查类型。其
中， 检查类型_的过程称为类型检查（type checking)
### 作用域
不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、等。
然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。

## 复合类型
是指基于其他类型定义的类型
### 引用
目前先为左值引用，后续c++11新增了右值引用
引用（reference）为对象起了另外一个名字，引用类型引用(refers to)另外一种类型
通过将声明符写出&d的形式来定义引用类型，其中d是声明的变量名

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和
它的初始值绑定（bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将
和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用
必须初始化
引用即别名，引用并非对象，相反的，它是为一个已经存在的对象所起的另外一个名字，一个引用之后，所有进行的
所有操作都是在与之绑定的对象上进行的
### 指针
指针（pointer)是“指向（point to)”另外一种类型的复合类型。与引用类似，指针 也
实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一指针本身 就
是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不 同
的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的 指
针如果没有被初始化，也将拥有一个不确定的值。

凡是定义了指针且不知道应该指向何处的就初始化为nullptr
#### 指向指针的指针
code:
## const限定符
在编译过程就能得到结果
一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定<br>

因为 const 对象一旦创建后其值就不能再改变，所以 const 对象必须初始化
如果利用一个对象去初始化另外 一
个对象，则它们是不是 const 都无关紧要

当以编译时初始化的方式定义一个 const 对象时，就如对 bufSize 的定义一样： const 
int bufSize = 512; // 输入缓冲区大小
编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到
代码中所有用到 bufSize 的地方，然后用 512 替换。

默认情况下，const 对象被设定为仅在文件内有效。当 多
个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量<br>
让多个文件共享这个const 变量解决办法： <br>
只在一个文件定义，在其他多个文件中声明并使用<br>
extern const int bufsize<br>


### const 引用
可以把引用绑定到 const 对象上，就像绑定到其他对象上一样，我们称之为对常量<br>
的引用（reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑<br>
定的对象：


### 指针和const
与引用易用，也可以令指针指向常量或非常量，指向常量的指针不能用于改变其所指对象的值，要<br>
存放常量对象的指针，只能用指向常量的指针

## 常量指针和指针常量：
指针常量：指针指向的地址不能修改，其指向的内容可以被修改 int const*p

常量指针：指向常量的指针变量为常量，指针指向的变量不可以通过该指针被修改，指针指向的值可以被修改 const int*p=&a

<strong>所谓指向常量的指针或引用，不过是指针或引用“自以为是<br>
罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值<br></strong>

### 顶层const
用名词顶层 const (top-level const)表示指针本身是个常量，<br>
而用名词底层 const (low-level const)表示指针所指的对象是一个常量

int *const pi = &i; //不能改变 pi 的值，这是一个顶层 const<br>
const int ci = 42; //不能改变 ci 的值，这是一个顶层 const<br>
const int *p2 = &ci; //允许改变 p2 的值，这是一个底层 const<br>

底层 const 的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出 的
对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般 来说，
非常量可以转换成常量，反之则不行

### constexpr和常量表达式
C++11 新标准规定，允许将变量声明为 constexpr 类型以便由编译器来验证变量的 p 值是否是
一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化

## 处理类型
类型别名是一个名字是某种类型的同义词
定义类型别名两种方法
一：***typedef*** typedef double wages ;//wages是double同义词

新标准：using SI= Sales_item //SI是Sales_item的同义词

遇到一条使用了类型别名的声明语句不要直接替换成它原本的样子来理解该语句的内容

auto 类型一般会忽略掉顶层const保留底层的const
## 定义数据结构
类只有数据成员（data member)。类的数据成员定义了类
的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不 会
影响其他对象。
